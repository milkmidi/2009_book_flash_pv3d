package{	import org.papervision3d.materials.shadematerials.PhongMaterial;	import org.papervision3d.objects.DisplayObject3D;	import org.papervision3d.objects.primitives.Cube;	import org.papervision3d.materials.utils.MaterialsList;	import org.papervision3d.view.BasicView;	import org.papervision3d.lights.PointLight3D;	import org.papervision3d.events.InteractiveScene3DEvent;	import caurina.transitions.Tweener;	import milkmidi.utils.NumberUtil;		import flash.display.*;	import flash.events.*;		public class Box3DWorld_03 extends MovieClip {		private var offset			:int = 280;		private	var light			:PointLight3D;		private var rootNode		:DisplayObject3D;		private var view			:BasicView;		private	var cursorOldX		:int = 0;				//上一影格滑鼠的座標位置		private	var cursorNewX		:int = 0;				//現在滑鼠的座標位置		private	var cursorVelocity	:int = 0;		//速率。		private var decay			:Number = 0.98;		//衰退值。		public function Box3DWorld_03(){			init3DEngine();			init3DObject();					}		private function init3DEngine():void{			view = new BasicView(0, 0, true, true, "Target");			view.camera.y = 850;			view.camera.z = -500;			view.camera.zoom = 3;			view.camera.focus = 90;			this.addChild(view);			this.addEventListener(Event.ENTER_FRAME, onEventRender3D);		}		private function init3DObject():void{			light = new PointLight3D();			light.y = 300;			rootNode = new DisplayObject3D();			rootNode.rotationZ = 15;			view.scene.addChild(rootNode);			var phongMat:PhongMaterial = new PhongMaterial(light, 0xffffff, 0x999999,10);			phongMat.interactive = true;			var ml:MaterialsList = new MaterialsList({all:phongMat});			for (var i:int = 0 ; i < 9; i++ ){				var _cube:Cube = new Cube(ml, 200, 200, 200);				_cube.name = "cube" + i;				_cube.addEventListener(InteractiveScene3DEvent.OBJECT_OVER, on3DOver);				_cube.addEventListener(InteractiveScene3DEvent.OBJECT_OUT, on3DOut);				_cube.extra =				{					vx	:0,					mode:0,					id	:i ,					x	:i % 3 * offset - offset,					y	:Math.floor(i / 3) * offset - offset				};				//mode為0時，表示方塊正在進場				//mode為1時，表示滑鼠RollOver方塊，此時將速率值為入方塊的extra.vx屬性。				//mode為2時，表示方塊的速率小於1，使用Tweener讓方塊轉回正面。				if(i == 4){					Tweener.addTween(_cube,					{						rotationY:720,						time:.7,						transition:"easeOutBack"											} );				}else{					_cube.scaleX = .2					_cube.scaleY = .2					_cube.scaleZ = .2					_cube.rotationX = NumberUtil.random( -360, 360);					_cube.rotationY = NumberUtil.random( -360, 360);					_cube.rotationZ = NumberUtil.random( -360, 360);					Tweener.addTween(_cube,					{						x		:_cube.extra.x,						y		:_cube.extra.y,						scaleX	:1,						scaleY	:1,						scaleZ	:1,						rotationX:0,						rotationY:0,						rotationZ:0,						time:.5,						delay:i * .03 + .7					} );				}				rootNode.addChild(_cube);			}		}		private function on3DOver(e:InteractiveScene3DEvent):void{			var _cube:Cube = e.displayObject3D as Cube;			_cube.extra.vx = cursorVelocity;			_cube.extra.mode = 1;			Tweener.addTween(_cube,			{				scale		:1.1,				time		: .5,				transition	:"easeOutBounce"			});		}		private function on3DOut(e:InteractiveScene3DEvent):void{			Tweener.addTween(e.displayObject3D,			{				scale		:1,				time		: .5,				transition	:"easeOutBounce"			});		}			private function onEventRender3D(e:Event):void{			cursorOldX = cursorNewX;						cursorNewX = stage.mouseX;									cursorVelocity = (cursorOldX - cursorNewX) / 10;			for (var i:int = 0 ; i < 9; i++){				var _cube:Cube = rootNode.getChildByName("cube" + i) as Cube;								if (_cube.extra.mode == 1) {					//如果方塊是在模式一，					//就讓方塊隨著滑鼠的速率旋轉					_cube.extra.vx *= decay;					_cube.rotationY += _cube.extra.vx;				}				if (Math.abs(_cube.extra.vx) < 1 && _cube.extra.mode == 1) {										//當方塊其旋轉速率小於1時，並模式是在1時。					_cube.extra.mode = 2;					//設定為模式2。					Tweener.addTween(_cube, { rotationY:0, time:.9 } );					//使用Tweener讓方塊轉正。				}			}			var _targetX:Number = (stage.stageWidth / 2 - stage.mouseX) / 2;			var _targetY:Number = (stage.stageHeight / 2 - stage.mouseY) / 2;			view.camera.x += (_targetX - view.camera.x) / 6;			view.camera.y += (_targetY - view.camera.y) / 6;						view.singleRender();		}	}}