package{	import org.papervision3d.materials.shadematerials.PhongMaterial;	import org.papervision3d.objects.DisplayObject3D;	import org.papervision3d.objects.primitives.Cube;	import org.papervision3d.materials.utils.MaterialsList;	import org.papervision3d.view.BasicView;	import org.papervision3d.lights.PointLight3D;	import org.papervision3d.events.InteractiveScene3DEvent;	import caurina.transitions.Tweener;	import milkmidi.utils.NumberUtil;		import flash.display.*;	import flash.events.*;		public class Box3DWorld_02 extends MovieClip {		private var offset			:int = 280;		private	var light			:PointLight3D;		private var rootNode		:DisplayObject3D;		private var view			:BasicView;		private	var cursorOldX		:int = 0;				//上一影格滑鼠的座標位置		private	var cursorNewX		:int = 0;				//現在滑鼠的座標位置		private	var cursorVelocity	:int = 0;		//速率。		private var decay			:Number = 0.98;		//衰退值。		public function Box3DWorld_02(){			init3DEngine();			init3DObject();					}		private function init3DEngine():void{			view = new BasicView(0, 0, true, true, "Target");			view.camera.y = 850;			view.camera.z = -500;			view.camera.zoom = 3;			view.camera.focus = 90;			this.addChild(view);			this.addEventListener(Event.ENTER_FRAME, onEventRender3D);		}		private function init3DObject():void{			light = new PointLight3D();			light.y = 300;			rootNode = new DisplayObject3D();			rootNode.rotationZ = 15;			view.scene.addChild(rootNode);			var phongMat:PhongMaterial = new PhongMaterial(light, 0xffffff, 0x999999,10);			phongMat.interactive = true;			var ml:MaterialsList = new MaterialsList({all:phongMat});			for (var i:int = 0 ; i < 9; i++ ){				var _cube:Cube = new Cube(ml, 200, 200, 200);				_cube.name = "cube" + i;				_cube.addEventListener(InteractiveScene3DEvent.OBJECT_OVER, on3DOver);				_cube.addEventListener(InteractiveScene3DEvent.OBJECT_OUT, on3DOut);				_cube.extra =				{					//為每個方塊指定自已特有的變數。					vx	:0,										//vx：旋轉速率。					x	:i % 3 * offset - offset,					//x：目標X軸。					y	:Math.floor(i / 3) * offset - offset					//y：目標Y軸。				};												if (i == 4) {					//如果i等於4的話，					//表示現在的方塊為正中間的方塊，					//使用Tweener修改其屬性。					Tweener.addTween(_cube,					{						rotationY	:720,						//依Y軸旋轉720度。						time		:.7,						transition	:"easeOutBack"											} );				}else {					//否則的話，表示是其他的方塊。					_cube.scaleX = .2					_cube.scaleY = .2					_cube.scaleZ = .2					//讓方塊縮小0.2倍。					_cube.rotationX = NumberUtil.random( -360, 360);					_cube.rotationY = NumberUtil.random( -360, 360);					_cube.rotationZ = NumberUtil.random( -360, 360);					//匯入筆者所撰寫的NumberUitl類別。					//取亂數值，範圍為-360到正360。					Tweener.addTween(_cube,					{						x		:_cube.extra.x,						y		:_cube.extra.y,						//使用Tweener，						//讓方塊定位到我們事先定義好的座標位置。						scaleX	:1,						scaleY	:1,												scaleZ	:1,						//回復到原本的大小。						rotationX:0,						rotationY:0,						rotationZ:0,						//方塊轉正。						time:.5,						//在0.5秒內完成。						delay:i * .03 + .7						//延遲Tweener事件發生。											} );				}				rootNode.addChild(_cube);			}		}		private function on3DOver(e:InteractiveScene3DEvent):void{			var _cube:Cube = e.displayObject3D as Cube;			_cube.extra.vx = cursorVelocity;				//將滑鼠的速率值寫入至cube裡的extra.vx屬性值。			Tweener.addTween(_cube,			{				scale		:1.1,				time		: .5,				transition	:"easeOutBounce"			});		}		private function on3DOut(e:InteractiveScene3DEvent):void{			Tweener.addTween(e.displayObject3D,			{				scale		:1,				time		: .5,				transition	:"easeOutBounce"			});		}				private function onEventRender3D(e:Event):void{			cursorOldX = cursorNewX;						cursorNewX = stage.mouseX;									cursorVelocity = (cursorOldX - cursorNewX) / 10;			//判斷滑鼠的速率。			for (var i:int = 0 ; i < 9; i++){				var _cube:Cube = rootNode.getChildByName("cube" + i) as Cube;				_cube.extra.vx *= decay;				//為每個方塊其旋轉速率值乘上衰退值。				_cube.rotationY += _cube.extra.vx;					//rotationY每次加上新的旋轉速率。			}			var _targetX:Number = (stage.stageWidth / 2 - stage.mouseX) / 2;			var _targetY:Number = (stage.stageHeight / 2 - stage.mouseY) / 2;			view.camera.x += (_targetX - view.camera.x) / 6;			view.camera.y += (_targetY - view.camera.y) / 6;						view.singleRender();		}	}}